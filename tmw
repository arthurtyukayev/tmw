#!/usr/bin/env bash
set -euo pipefail

readonly TMUXP_DIR="$HOME/.tmuxp"
readonly VERSION="0.1.6"

# ─── Configuration ───────────────────────────────────────
readonly CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/tmw"
readonly CONFIG_FILE="$CONFIG_DIR/config.yml"

# Load branch prefix from config file (defaults to empty)
get_branch_prefix() {
  if [[ -f "$CONFIG_FILE" ]]; then
    local prefix
    prefix="$(sed -n '/^branch_prefix:/ { s/^branch_prefix:[[:space:]]*//; p; q; }' "$CONFIG_FILE")"
    prefix="${prefix//\"/}"
    prefix="${prefix//\'/}"
    printf '%s\n' "$prefix"
  else
    printf '\n'
  fi
}

# Detect the default branch of a git repository (main, master, etc.)
get_default_branch() {
  local repo_path="$1"
  local default_branch
  default_branch=$(git -C "$repo_path" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
  if [[ -z "$default_branch" ]]; then
    # Fallback to checking for common branch names
    for branch in main master trunk develop; do
      if git -C "$repo_path" show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
        echo "$branch"
        return
      fi
    done
    die "Cannot determine default branch for repository: $repo_path"
  fi
  echo "$default_branch"
}

# Find tmuxp config file with either .yaml or .yml extension
# Usage: find_config_file "name" "type" (type: static or worktree)
find_config_file() {
  local name="$1"
  local type="${2:-static}"
  local extensions=("yaml" "yml")

  for ext in "${extensions[@]}"; do
    local config_file
    if [[ "$type" == "worktree" ]]; then
      config_file="$TMUXP_DIR/${name}.worktree.${ext}"
    else
      config_file="$TMUXP_DIR/${name}.${ext}"
    fi
    [[ -f "$config_file" ]] && { echo "$config_file"; return 0; }
  done

  return 1
}



# ─── Colors ──────────────────────────────────────────────
red()    { printf '\033[0;31m%s\033[0m\n' "$*"; }
green()  { printf '\033[0;32m%s\033[0m\n' "$*"; }
yellow() { printf '\033[0;33m%s\033[0m\n' "$*"; }
bold()   { printf '\033[1m%s\033[0m\n' "$*"; }

die() { red "error: $*" >&2; exit 1; }
warn() { yellow "warning: $*" >&2; }
info() { green "$*"; }

# Verify required external commands are available.
require_command() {
  local cmd="$1"
  command -v "$cmd" >/dev/null 2>&1 || die "missing dependency: '$cmd' is not installed or not in PATH"
}

require_commands() {
  local cmd
  for cmd in "$@"; do
    require_command "$cmd"
  done
}

# ─── Help ────────────────────────────────────────────────
usage() {
  cat <<'EOF'
tmw - tmux worktree manager

Usage: tmw <command> [args]

Commands:
  init     Generate tmuxp configs for a new project
  new      Create worktrees and start a tmuxp session
  kill     Kill an active tmux session
  destroy  Kill session and remove worktrees
  attach   Attach to an existing session
  list     List active worktree sessions
  version  Show version information

Run 'tmw <command> --help' for details and examples.
EOF
}

usage_init() {
  cat <<'EOF'
Generate tmuxp configs for a new project.

Creates two configs in ~/.tmuxp/:
  <name>.yaml            Static config for main branch
  <name>.worktree.yaml   Parameterized for worktrees

Usage:
  tmw init <name> --type=<type> --backend=<path> [--frontend=<path>]

Options:
  --type       fullstack or single (required)
  --backend    Path to backend/main repo (required)
  --frontend   Path to frontend repo (fullstack only)

Examples:
  # Fullstack project (backend + frontend)
  tmw init myapp \
    --type=fullstack \
    --backend=~/Projects/myapp/backend \
    --frontend=~/Projects/myapp/frontend

  # Single repo project
  tmw init myproject \
    --type=single \
    --backend=~/Projects/Personal/myproject
EOF
}

usage_new() {
  cat <<'EOF'
Create git worktrees and start a tmuxp session.

Creates branch at/<feature> from main in each repo,
sets up worktree directories as siblings of the repos,
and launches the tmuxp session.

If worktrees already exist, skips creation and just
launches the session.

Without a feature name, loads the static config for
the main branch (no worktrees created).

Usage:
  tmw new <config> [feature]

Arguments:
  config    Project name (matches tmuxp config)
  feature   Feature name (optional; branch and dir suffix)

Examples:
  # Start main-branch session (static config)
  tmw new myapp

  # Start worktree session
  tmw new myapp feature-name
  tmw new myproject new-feature
EOF
}

usage_kill() {
  cat <<'EOF'
Kill an active tmux session.

Kills the tmux session if it exists. Does not remove
worktrees or delete branches. Use 'destroy' to also
remove worktrees.

Usage:
  tmw kill <session>

Arguments:
  session   Session name (as shown in tmux list-sessions)

Examples:
  tmw kill allcore-machine-os
  tmw kill myapp-feature-name
EOF
}

usage_destroy() {
  cat <<'EOF'
Destroy worktree session and remove worktrees.

Kills the tmux session, removes worktree directories
from all repos. Does not delete git branches.

Usage:
  tmw destroy <config> <feature>

Arguments:
  config    Project name
  feature   Feature name

Examples:
  tmw destroy myapp feature-name
  tmw destroy myproject new-feature
EOF
}

usage_attach() {
  cat <<'EOF'
Attach to an existing tmux session.

Attaches only if the tmux session is already running.
If the session does not exist, exits with an error.

Without a feature name, attaches to the main-branch
session (static config).

Usage:
  tmw attach <config> [feature]

Arguments:
  config    Project name
  feature   Feature name (optional)

Examples:
  # Attach to main-branch session
  tmw attach myapp

  # Attach to worktree session
  tmw attach myapp feature-name
  tmw attach myproject new-feature
EOF
}

usage_list() {
  cat <<'EOF'
List active worktree sessions.

Shows all tmw-managed worktree sessions with status.
Without arguments, lists all projects. With a config
name, filters to that project.

Usage:
  tmw list [config]

Arguments:
  config    Project name (optional, filters output)

Examples:
  # List all projects
  tmw list

  # List worktrees for one project
  tmw list myapp

Output:
  CONFIG    FEATURE              STATUS
  myapp   feature-name   attached
  myapp   another-feat        detached
  myproject   new-feature       no session
EOF
}

# ─── Shared Helpers ──────────────────────────────────────

# Read a value from a worktree config's environment block.
# Usage: parse_config_env <config-file> <key>
parse_config_env() {
  local config_file="$1" key="$2"
  sed -n "/^  ${key}:/ { s/^  ${key}: *//; p; q; }" "$config_file"
}

# Read session_name template from worktree config.
# Usage: parse_session_template <config-file>
parse_session_template() {
  local config_file="$1"
  sed -n '/^session_name:/ { s/^session_name: *//; p; q; }' "$config_file"
}

# Derive actual session name by replacing ${WORKTREE} with feature.
# Usage: derive_session_name <template> <feature>
derive_session_name() {
  local template="$1" feature="$2"
  printf '%s\n' "${template//\$\{WORKTREE\}/$feature}"
}

# Derive worktree directory paths.
# Sets global vars: BACKEND_DIR, FRONTEND_DIR (empty if single), BACKEND_REPO, FRONTEND_REPO
# Usage: derive_paths <config-file> <feature>
derive_paths() {
  local config_file="$1" feature="$2"

  BACKEND_REPO="$(parse_config_env "$config_file" "BACKEND_REPO")"
  [[ -n "$BACKEND_REPO" ]] || die "BACKEND_REPO not found in worktree config"

  BACKEND_DIR="${BACKEND_REPO}-${feature}"

  FRONTEND_REPO="$(parse_config_env "$config_file" "FRONTEND_REPO" 2>/dev/null || true)"
  if [[ -n "$FRONTEND_REPO" ]]; then
    FRONTEND_DIR="${FRONTEND_REPO}-${feature}"
    PROJECT_TYPE="fullstack"
  else
    FRONTEND_DIR=""
    PROJECT_TYPE="single"
  fi
}

# Read session_name from the static config.
# Usage: parse_static_session_name <config-file>
parse_static_session_name() {
  local config_file="$1"
  sed -n '/^session_name:/ { s/^session_name: *//; p; q; }' "$config_file"
}

# Check if a tmux session exists.
# Usage: session_exists <session-name>
session_exists() {
  tmux has-session -t "$1" 2>/dev/null
}

# ─── init ────────────────────────────────────────────────
cmd_init() {
  local name="" type="" backend="" frontend=""

  # First positional arg is the name
  if [[ $# -gt 0 && "${1:0:1}" != "-" ]]; then
    name="$1"; shift
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h)    usage_init; exit 0 ;;
      --type=*)     type="${1#--type=}" ;;
      --type)       shift; type="${1:-}" ;;
      --backend=*)  backend="${1#--backend=}" ;;
      --backend)    shift; backend="${1:-}" ;;
      --frontend=*) frontend="${1#--frontend=}" ;;
      --frontend)   shift; frontend="${1:-}" ;;
      *)
        if [[ -z "$name" ]]; then
          name="$1"
        else
          die "unexpected argument: $1"
        fi
        ;;
    esac
    shift
  done

  # Validation
  [[ -n "$name" ]]    || die "name is required. Run 'tmw init --help' for usage."
  [[ -n "$type" ]]    || die "--type is required (fullstack or single)"
  [[ -n "$backend" ]] || die "--backend is required"

  [[ "$type" == "fullstack" || "$type" == "single" ]] || \
    die "--type must be 'fullstack' or 'single'"

  # Expand ~ in paths
  backend="${backend/#\~/$HOME}"
  frontend="${frontend/#\~/$HOME}"

  # Resolve to absolute paths
  backend="$(cd "$backend" 2>/dev/null && pwd)" || die "backend path does not exist: $backend"
  [[ -d "$backend/.git" || -f "$backend/.git" ]] || die "backend is not a git repo: $backend"

  if [[ "$type" == "fullstack" ]]; then
    [[ -n "$frontend" ]] || die "--frontend is required for fullstack type"
    frontend="$(cd "$frontend" 2>/dev/null && pwd)" || die "frontend path does not exist: $frontend"
    [[ -d "$frontend/.git" || -f "$frontend/.git" ]] || die "frontend is not a git repo: $frontend"
  else
    [[ -z "$frontend" ]] || die "--frontend is not allowed for single type"
  fi

  local static_config="$TMUXP_DIR/${name}.yaml"
  local worktree_config="$TMUXP_DIR/${name}.worktree.yaml"

  # Generate configs
  if [[ "$type" == "fullstack" ]]; then
    _generate_fullstack_static "$name" "$backend" "$frontend" > "$static_config"
    _generate_fullstack_worktree "$name" "$backend" "$frontend" > "$worktree_config"
  else
    _generate_single_static "$name" "$backend" > "$static_config"
    _generate_single_worktree "$name" "$backend" > "$worktree_config"
  fi

  info "Created $static_config"
  info "Created $worktree_config"
  echo ""
  echo "Edit the 'srv' window commands in the configs if needed."
}

_generate_fullstack_static() {
  local name="$1" backend="$2" frontend="$3"
  cat <<EOF
session_name: ${name}
windows:
- window_name: nvim
  layout: even-horizontal
  panes:
  - focus: 'true'
    shell_command:
    - cd ${backend}
    - nvim .
  - shell_command:
    - cd ${frontend}
    - nvim .
- window_name: oc
  panes:
  - focus: 'true'
    shell_command: opencode
  start_directory: ${backend}
- window_name: srv
  focus: 'true'
  layout: even-horizontal
  panes:
  - focus: 'true'
    shell_command:
    - cd ${backend}
    - pnpm run dev
  - shell_command:
    - cd ${frontend}
    - pnpm run dev
- window_name: gitui
  layout: even-horizontal
  panes:
  - focus: 'true'
    shell_command:
    - cd ${backend}
    - gitui
  - shell_command:
    - cd ${frontend}
    - gitui
EOF
}

_generate_single_static() {
  local name="$1" backend="$2"
  cat <<EOF
session_name: ${name}
windows:
- window_name: nvim
  panes:
  - focus: 'true'
    shell_command:
    - cd ${backend}
    - nvim .
- window_name: oc
  panes:
  - focus: 'true'
    shell_command: opencode
  start_directory: ${backend}
- window_name: srv
  focus: 'true'
  panes:
  - focus: 'true'
    shell_command:
    - cd ${backend}
    - pnpm run dev
- window_name: gitui
  panes:
  - focus: 'true'
    shell_command:
    - cd ${backend}
    - gitui
EOF
}

_generate_fullstack_worktree() {
  local name="$1" backend="$2" frontend="$3"
  cat <<EOF
session_name: ${name}-\${WORKTREE}
environment:
  BACKEND_REPO: ${backend}
  FRONTEND_REPO: ${frontend}
windows:
- window_name: nvim
  layout: even-horizontal
  panes:
  - focus: 'true'
    shell_command:
    - cd \${BACKEND}
    - nvim .
  - shell_command:
    - cd \${FRONTEND}
    - nvim .
- window_name: oc
  panes:
  - focus: 'true'
    shell_command: opencode
  start_directory: \${BACKEND}
- window_name: srv
  focus: 'true'
  layout: even-horizontal
  panes:
  - focus: 'true'
    shell_command:
    - cd \${BACKEND}
    - pnpm run dev
  - shell_command:
    - cd \${FRONTEND}
    - pnpm run dev
- window_name: gitui
  layout: even-horizontal
  panes:
  - focus: 'true'
    shell_command:
    - cd \${BACKEND}
    - gitui
  - shell_command:
    - cd \${FRONTEND}
    - gitui
EOF
}

_generate_single_worktree() {
  local name="$1" backend="$2"
  cat <<EOF
session_name: ${name}-\${WORKTREE}
environment:
  BACKEND_REPO: ${backend}
windows:
- window_name: nvim
  panes:
  - focus: 'true'
    shell_command:
    - cd \${BACKEND}
    - nvim .
- window_name: oc
  panes:
  - focus: 'true'
    shell_command: opencode
  start_directory: \${BACKEND}
- window_name: srv
  focus: 'true'
  panes:
  - focus: 'true'
    shell_command:
    - cd \${BACKEND}
    - pnpm run dev
- window_name: gitui
  panes:
  - focus: 'true'
    shell_command:
    - cd \${BACKEND}
    - gitui
EOF
}

# ─── new ─────────────────────────────────────────────────
cmd_new() {
  local config="" feature=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h) usage_new; exit 0 ;;
      -*)        die "unknown option: $1" ;;
      *)
        if [[ -z "$config" ]]; then
          config="$1"
        elif [[ -z "$feature" ]]; then
          feature="$1"
        else
          die "unexpected argument: $1"
        fi
        ;;
    esac
    shift
  done

  [[ -n "$config" ]] || die "config name is required. Run 'tmw new --help' for usage."

  # No feature — load the static (main branch) config
  if [[ -z "$feature" ]]; then
    local static_config
    static_config=$(find_config_file "$config" "static") || die "static config not found for: $config. Run 'tmw init' first."
    info "Launching static session: ${config}"
    tmuxp load "$static_config"
    return
  fi

  local config_file
  config_file=$(find_config_file "$config" "worktree") || die "worktree config not found for: $config. Run 'tmw init' first."

  # Derive paths
  derive_paths "$config_file" "$feature"

  local prefix branch
  prefix="$(get_branch_prefix)"
  branch="${prefix}${feature}"
  if [[ -n "$prefix" ]]; then
    info "Using branch prefix from ${CONFIG_FILE}: '${prefix}'"
  else
    info "Using branch prefix from ${CONFIG_FILE}: <none>"
  fi

  # Create backend worktree if dir doesn't exist
  if [[ ! -d "$BACKEND_DIR" ]]; then
    info "Creating backend worktree: $BACKEND_DIR"
    # Check if branch already exists
    if git -C "$BACKEND_REPO" show-ref --verify --quiet "refs/heads/${branch}" 2>/dev/null; then
      info "Branch ${branch} already exists, attaching to it"
      git -C "$BACKEND_REPO" worktree add "$BACKEND_DIR" "$branch"
    else
      local default_branch
      default_branch=$(get_default_branch "$BACKEND_REPO")
      git -C "$BACKEND_REPO" worktree add -b "$branch" "$BACKEND_DIR" "$default_branch"
    fi
  else
    info "Backend worktree already exists: $BACKEND_DIR"
  fi

  # Create frontend worktree if fullstack
  if [[ "$PROJECT_TYPE" == "fullstack" ]]; then
    if [[ ! -d "$FRONTEND_DIR" ]]; then
      info "Creating frontend worktree: $FRONTEND_DIR"
      if git -C "$FRONTEND_REPO" show-ref --verify --quiet "refs/heads/${branch}" 2>/dev/null; then
        info "Branch ${branch} already exists, attaching to it"
        git -C "$FRONTEND_REPO" worktree add "$FRONTEND_DIR" "$branch"
      else
        local default_branch
        default_branch=$(get_default_branch "$FRONTEND_REPO")
        git -C "$FRONTEND_REPO" worktree add -b "$branch" "$FRONTEND_DIR" "$default_branch"
      fi
    else
      info "Frontend worktree already exists: $FRONTEND_DIR"
    fi
  fi

  # Launch tmuxp
  info "Launching tmuxp session: ${config}.worktree"
  local -a env_vars=(
    "WORKTREE=${feature}"
    "BACKEND=${BACKEND_DIR}"
  )
  if [[ "$PROJECT_TYPE" == "fullstack" ]]; then
    env_vars+=("FRONTEND=${FRONTEND_DIR}")
  fi

  env "${env_vars[@]}" tmuxp load "$config_file"
}

# ─── kill ────────────────────────────────────────────────
cmd_kill() {
  local session=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h) usage_kill; exit 0 ;;
      -*)        die "unknown option: $1" ;;
      *)
        if [[ -z "$session" ]]; then
          session="$1"
        else
          die "unexpected argument: $1"
        fi
        ;;
    esac
    shift
  done

  [[ -n "$session" ]] || die "session name is required. Run 'tmw kill --help' for usage."

  # Kill tmux session if it exists
  if session_exists "$session"; then
    info "Killing session: $session"
    tmux kill-session -t "$session"
  else
    warn "Session not found: $session"
  fi
}

# ─── destroy ────────────────────────────────────────────────
cmd_destroy() {
  local config="" feature=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h) usage_destroy; exit 0 ;;
      -*)        die "unknown option: $1" ;;
      *)
        if [[ -z "$config" ]]; then
          config="$1"
        elif [[ -z "$feature" ]]; then
          feature="$1"
        else
          die "unexpected argument: $1"
        fi
        ;;
    esac
    shift
  done

  [[ -n "$config" ]]  || die "config name is required. Run 'tmw destroy --help' for usage."
  [[ -n "$feature" ]] || die "feature name is required. Run 'tmw destroy --help' for usage."

  local config_file
  config_file=$(find_config_file "$config" "worktree") || die "worktree config not found for: $config"

  # Derive session name and paths
  derive_paths "$config_file" "$feature"

  local session_template session_name
  session_template="$(parse_session_template "$config_file")"
  session_name="$(derive_session_name "$session_template" "$feature")"

  # Kill tmux session if it exists
  if session_exists "$session_name"; then
    info "Killing session: $session_name"
    tmux kill-session -t "$session_name"
  else
    warn "Session not found: $session_name"
  fi

  # Remove worktrees
  if [[ -d "$BACKEND_DIR" ]]; then
    info "Removing backend worktree: $BACKEND_DIR"
    git -C "$BACKEND_REPO" worktree remove "$BACKEND_DIR" 2>/dev/null || \
      git -C "$BACKEND_REPO" worktree remove --force "$BACKEND_DIR" 2>/dev/null || \
      warn "Failed to remove backend worktree"
  fi

  if [[ "$PROJECT_TYPE" == "fullstack" ]]; then
    if [[ -d "$FRONTEND_DIR" ]]; then
      info "Removing frontend worktree: $FRONTEND_DIR"
      git -C "$FRONTEND_REPO" worktree remove "$FRONTEND_DIR" 2>/dev/null || \
        git -C "$FRONTEND_REPO" worktree remove --force "$FRONTEND_DIR" 2>/dev/null || \
        warn "Failed to remove frontend worktree"
    fi
  fi

  info "Worktrees cleaned up for ${config} ${feature}"
}

# ─── attach ────────────────────────────────────────────────
cmd_attach() {
  local config="" feature=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h) usage_attach; exit 0 ;;
      -*)        die "unknown option: $1" ;;
      *)
        if [[ -z "$config" ]]; then
          config="$1"
        elif [[ -z "$feature" ]]; then
          feature="$1"
        else
          die "unexpected argument: $1"
        fi
        ;;
    esac
    shift
  done

  [[ -n "$config" ]] || die "config name is required. Run 'tmw attach --help' for usage."

  # No feature — attach to main-branch session
  if [[ -z "$feature" ]]; then
    local static_config
    static_config=$(find_config_file "$config" "static") || die "static config not found for: $config"

    local static_session
    static_session="$(parse_static_session_name "$static_config")"
    if session_exists "$static_session"; then
      info "Attaching to session: $static_session"
      tmux attach-session -t "$static_session"
    else
      die "Session not found: $static_session. Run 'tmw new $config' first."
    fi
    return
  fi

  # Validate worktree config exists and derive session name
  local config_file
  config_file=$(find_config_file "$config" "worktree") || die "worktree config not found for: $config"

  # Derive session name
  local session_template session_name
  session_template="$(parse_session_template "$config_file")"
  session_name="$(derive_session_name "$session_template" "$feature")"

  # Session exists — attach directly
  if session_exists "$session_name"; then
    info "Attaching to session: $session_name"
    tmux attach-session -t "$session_name"
    return
  fi

  die "Session not found: $session_name. Run 'tmw new ${config} ${feature}' first."
}

# ─── list ────────────────────────────────────────────────
cmd_list() {
  local filter_config=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h) usage_list; exit 0 ;;
      -*)        die "unknown option: $1" ;;
      *)
        if [[ -z "$filter_config" ]]; then
          filter_config="$1"
        else
          die "unexpected argument: $1"
        fi
        ;;
    esac
    shift
  done

  # Get active tmux sessions
  local tmux_sessions=""
  tmux_sessions="$(tmux list-sessions -F '#{session_name}' 2>/dev/null || true)"
  local tmux_sessions_wrapped=$'\n'"$tmux_sessions"$'\n'

  # Get current attached session (if any)
  local attached_session=""
  attached_session="$(tmux display-message -p '#{session_name}' 2>/dev/null || true)"

  # Header
  printf "%-14s %-24s %s\n" "CONFIG" "FEATURE" "STATUS"
  printf "%-14s %-24s %s\n" "------" "-------" "------"

  local found=0

  # Scan worktree configs (support both .yaml and .yml)
  for config_file in "$TMUXP_DIR"/*.worktree.{yaml,yml}; do
    [[ -f "$config_file" ]] || continue

    local config_basename config_name
    config_basename="${config_file##*/}"
    config_name="${config_basename%.worktree.yaml}"
    config_name="${config_name%.worktree.yml}"

    # Apply filter
    if [[ -n "$filter_config" && "$config_name" != "$filter_config" ]]; then
      continue
    fi

    # Get backend repo from config
    local backend_repo
    backend_repo="$(parse_config_env "$config_file" "BACKEND_REPO")"
    [[ -n "$backend_repo" ]] || continue

    local session_template
    session_template="$(parse_session_template "$config_file")"
    [[ -n "$session_template" ]] || continue

    # List worktrees for this repo
    local worktree_list
    worktree_list="$(git -C "$backend_repo" worktree list --porcelain 2>/dev/null || true)"

    # Parse worktrees — find those matching <repo-basename>-<feature>
    local repo_basename
    repo_basename="${backend_repo##*/}"

    # Look for worktree dirs matching <repo-basename>-<feature>
    while IFS= read -r line; do
      if [[ "$line" =~ ^worktree\ (.+)$ ]]; then
        local wt_path="${BASH_REMATCH[1]}"
        local wt_basename
        wt_basename="${wt_path##*/}"

        # Check if this worktree matches our naming convention
        if [[ "$wt_basename" == "${repo_basename}-"* ]]; then
          local feature="${wt_basename#${repo_basename}-}"

          # Derive session name
          local session_name="${session_template//\$\{WORKTREE\}/$feature}"

          # Determine status
          local status="no session"
          if [[ "$tmux_sessions_wrapped" == *$'\n'"$session_name"$'\n'* ]]; then
            if [[ "$session_name" == "$attached_session" ]]; then
              status="attached"
            else
              status="detached"
            fi
          fi

          printf "%-14s %-24s %s\n" "$config_name" "$feature" "$status"
          found=1
        fi
      fi
    done <<< "$worktree_list"
  done

  if [[ "$found" -eq 0 ]]; then
    echo "No worktree sessions found."
  fi
}

# ─── Main Dispatcher ─────────────────────────────────────
main() {
  if [[ $# -eq 0 ]]; then
    usage
    exit 0
  fi

  local cmd="$1"
  shift

  case "$cmd" in
    init)
      require_commands git
      cmd_init "$@"
      ;;
    new)
      require_commands git tmuxp
      cmd_new "$@"
      ;;
    kill)
      require_commands tmux
      cmd_kill "$@"
      ;;
    destroy)
      require_commands git tmux
      cmd_destroy "$@"
      ;;
    attach)
      require_commands tmux
      cmd_attach "$@"
      ;;
    list|ls)
      require_commands git tmux
      cmd_list "$@"
      ;;
    version)  echo "tmw $VERSION"; exit 0 ;;
    --help|-h|help) usage; exit 0 ;;
    --version|-v)   echo "tmw $VERSION"; exit 0 ;;
    *)        die "unknown command: $cmd. Run 'tmw --help' for usage." ;;
  esac
}

main "$@"
